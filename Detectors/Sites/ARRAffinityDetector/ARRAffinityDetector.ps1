param([string]$resourceToProcess, [string]$currDetectorName) #Must be the first statement in the script

<#
1. Make sure there are no spaces in the Detector script name. Place your Detector script within a folder with the same name as your detector script. You can then put this folder inside the \Detectors\Sites or Detectors\ASPs directory
For e.g.. The sample SlotsDetector.ps1 is a Sites Detector and its script is placed inside \Detectors\Sites\SlotsDetector\SlotsDetector.ps1

2. No individual Detector should take more than a few minutes to complete. It runs a risk of being terminated if it runs for a long time
Timeout for a Site detector is 6 minutes and for an ASP detector is 10 minutes

3. As a rule of thumb, if you are downloading any file that you need for your detector to function, download it in the Sites directory respresnted by $resourceToProcess instead of the directory in which your Detectory resides.
You may choose to clean up / leave the downloaded data as is. Just in case any other detectory needs it, it will already have it there.
Simillarly, if you need a file downloaded / some data, check for its presence. Chances are, some other detector might have already done the work for you


4. $resourceToProcess will have input in the following format
    C:\Projects\AntaresBestPracticeAnalyzer-Windows\Output\da511dea-6e00-4728-93ff-6302ad7fe284\Sites\da511dea-6e00-4728-93ff-6302ad7fe284_nmallickWebAppRG_nmallick1

5. Once done with the detector logic, create a file with the following naming convention and place it in the same folder as $resourceToProcess
    DetectorName.out.

    For e.g. If the detector's name is SlotsDetector, the output file generated by this detector should be SlotsDetector.out and should be placed at $resourceToProcess +"\SlotsDetector.out".
    $detectorOutputFile valiable already creates the complete file path for you.

    The output file should contain and output in the following JSON format

    {
    "SubscriptionId": "This should be the Subscription ID under which the current site resides",
    "ResourceGroupName": "This should be the resource grop name under which the current site resides",
    "ResourceName": "This should be either the name of the webapp or ASP that the detector is currently processing",
    "Kind": "Make sure value is one out of SiteDector | ASPDetector",
    "DetectorName": "SlotsDetector",
    "Author": "Feel free to addd your name and/or email address or simply state Anonymous"
    "Description": "In short, state which best practice does your detector checks against",
    "Result":{
        "Value": "Make sure value is one out of Pass | Fail | Warning",
        "Details": "Any string decribing what is the conclusion of your detector",
        "Recommendation": "What is your recommendation for this site and why",
        "AdditionalInfo":"Anything else that you want to point out goes here"
        }
    }

6. Add a small description of what your detector checks for / which best practice is it trying to look for in the corresponding ReadMe.txt. It will help people understand the intent of this detector.

7. There is a return statement in PlaceHolderDetector.ps1. Remove / Comment it before working on your detector. It is placed to ensure that the PlaceHolderDetecor does not run any logic if trigerred

8. The order in which Detectors will be invoked is not guaranteed, however they are certain to be invoked ONLY once per Site / ASP.
#>




#region Do not change anything in this section
    $detectorOutputFile = $resourceToProcess + "\" + $currDetectorName  + ".out"

    if(Test-Path -Path $detectorOutputFile){
        #Output for this detector already exists. Must have been trigerred due to some bug / error. Do not run the detector logic again
        return
    }

    $temp = $resourceToProcess.Split('\')[$resourceToProcess.Split('\').Length-1]

    $subscriptionId = $temp.Split('_')[0]
    $resourceGroup = $temp.Split('_')[1]
    $resourceName = $temp.Split('_')[2]

    #The complete path of the JSON file that contains settings for this resource is $resourceToProcess + "\" + $settingsFileName
    $settingsFileName = $resourceName + ".json"

    #Initialize
    $adheringToBestPractice = $true
#endregion Do not change anything in this section

#region Code for your detector goes here
    $siteProperties = Get-Content -Path ($resourceToProcess + "\" + $settingsFileName) |ConvertFrom-Json
    If($siteProperties.clientAffinityEnabled)
    {
        #ARR Affinity is enabled for this site. Load may not be efficiently balanced amongs servers. Check to see how many instnaces is this site hosted on
        $adheringToBestPractice = $false

        $instanceListURL = "/subscriptions/" + $subscriptionId + "/resourceGroups/" + $resourceGroup + "/providers/Microsoft.Web/sites/" + $resourceName + "/instances?api-version=2016-08-01"
        $instancesForThisSite = ARMClient.exe Get $instanceListURL | ConvertFrom-Json
        if($instancesForThisSite.value.Count -gt 1)
        {
            $failureDetails = "ARR Affinity is enabled for this site. There are " + $instancesForThisSite.value.Count + " instances serving this site and due to ARR Affinity, traffic distribution across these instances may not be optimal."
        }
        else
        {
            $failureDetails = "ARR Affinity is enabled for this site. With only 1 instance serving this site, disabling ARR Affinity will not impact it in anyway. However, if the site is scaled out with ARR Affinity enabled, traffic distribution across these instances may not be optimal."
        }
    }
    else
    {
        #ARR Affinity is already disabled to this site.
        $adheringToBestPractice = $true
    }

#endregion  Code for your detector goes here

#region Generate output for the detector
    #region Modify the text in variables as appropriate
        If($adheringToBestPractice){
            #Enter this block if you logic found that the best practice you are checking for is already implemented for this site
            $detectorResult = @{
                'Value'='Pass';
                'Details'='ARR Affinity is disabled for this site. This ensures load is equally distributed across multiple instances hosting the site';
                'Recommendation'='';
                'AdditionalInfo'=''
                }
        }
        else
        {
            #Enter this block if you logic found that the best practice you are checking for is already implemented for this site
            $detectorResult = @{
                'Value'='Fail';
                'Details'= $failureDetails;
                'Recommendation'='You can improve the performance of your stateless applications by turning off ARR Affinity, state-full applications should keep ARR Affinity turned on for compatibility. Kindly consult with your application developer before disabling ARR Affinity for this site.';
                'AdditionalInfo'="For more information on understanding how ARR Affinity works, kindly refer to the article https://blogs.msdn.microsoft.com/appserviceteam/2016/05/16/disable-session-affinity-cookie-arr-cookie-for-azure-web-apps/ "
                }
        }




        #region Generating output for the detector
        $outputObj = New-Object System.Object
        $outputObj  | Add-Member -MemberType NoteProperty -Name SubscriptionId -Value $subscriptionId
        $outputObj  | Add-Member -MemberType NoteProperty -Name ResourceGroupName -Value $resourceGroup
        $outputObj  | Add-Member -MemberType NoteProperty -Name ResourceName -Value $resourceName
        $outputObj  | Add-Member -MemberType NoteProperty -Name Kind -Value "SiteDetector"
        $outputObj  | Add-Member -MemberType NoteProperty -Name DetectorName -Value $currDetectorName
        $outputObj  | Add-Member -MemberType NoteProperty -Name Author -Value "Nazeef Mallick (nmallick@microsoft.com)"
        $outputObj  | Add-Member -MemberType NoteProperty -Name Description -Value "Ensure ARR Affinity is disabled."
        $outputObj  | Add-Member -MemberType NoteProperty -Name Result -Value $detectorResult



    #endregion  Modify the text in variables as appropriate

    #region Write output to .out file
        #Create a placeholder file
        New-Item -ItemType File -Path $detectorOutputFile -Force >$null

        #Write the properties of this website into its corresponding file
        $outputObj | ConvertTo-Json | Out-File -FilePath $detectorOutputFile -Append  -Force
    #endregion Write output to .out file
#endregion  Generate output for the detector